// Generated by CoffeeScript 1.4.0
(function() {
  var CameraController, GuiController, LightController, Lines, Monster, Octopus, Tentacle, TestSection, addListener, addStat, camera, composer, currentSection, currentSectionType, imagesLoaded, lines, mainLoop, mouseX, mouseY, onDocumentMouseMove, onDocumentTouchMove, onDocumentTouchStart, preload, renderer, scene, sh, stats, sw, tanFOV,
    _this = this,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  CameraController = (function() {

    CameraController.prototype.camera = null;

    CameraController.prototype.rotation = 0;

    CameraController.prototype.y = 0;

    CameraController.prototype.radius = 320;

    CameraController.prototype.radiusOffset = 0;

    CameraController.prototype.maxY = 100;

    CameraController.prototype.minY = -100;

    CameraController.prototype.radiusfriction = 0.95;

    function CameraController(camera) {
      this.camera = camera;
      return;
    }

    CameraController.prototype.update = function(vx, vy) {
      var x, y, z;
      this.rotation += vx;
      this.y += vy;
      this.y = Math.max(Math.min(this.y, this.maxY), this.minY);
      if (this.y < this.maxY - 120) {
        this.radiusOffset += (Math.abs(vy * 10) - this.radiusOffset) * .5;
      } else {
        this.radiusOffset *= .95;
      }
      x = Math.cos(this.rotation) * (this.radius + this.radiusOffset);
      y = this.y;
      z = Math.sin(this.rotation) * (this.radius + this.radiusOffset);
      this.camera.position.set(x, y, z);
      this.camera.lookAt(new THREE.Vector3(0, this.y + vy * 10, 0));
    };

    return CameraController;

  })();

  LightController = (function() {

    LightController.prototype.ambientLight = null;

    LightController.prototype.ambientLightColor = [0x0F, 0x0F, 0x0F];

    LightController.prototype.cameraLight = null;

    LightController.prototype.cameraLightColor = [0xFF, 0xFF, 0xFF];

    LightController.prototype.lightAuto = false;

    LightController.prototype.scene = null;

    LightController.prototype.camera = null;

    function LightController(scene, camera, radius) {
      this.scene = scene;
      this.camera = camera;
      this.radius = radius;
      this.ambientLight = new THREE.AmbientLight(0xffffff);
      this.scene.add(this.ambientLight);
      this.cameraLight = new THREE.PointLight(0xffffff, 1, this.radius * 2);
      this.scene.add(this.cameraLight);
      return;
    }

    LightController.prototype.update = function() {
      if (!this.lightAuto) {
        this.ambientLight.color.setRGB(this.ambientLightColor[0] / 0xFF, this.ambientLightColor[1] / 0xFF, this.ambientLightColor[2] / 0xFF);
        this.cameraLight.color.setRGB(this.cameraLightColor[0] / 0xFF, this.cameraLightColor[1] / 0xFF, this.cameraLightColor[2] / 0xFF);
      }
      this.cameraLight.position.x = this.camera.position.x;
      this.cameraLight.position.y = this.camera.position.y;
      return this.cameraLight.position.z = this.camera.position.z;
    };

    return LightController;

  })();

  Lines = (function() {

    Lines.prototype.distance = 600;

    Lines.prototype.amount = 60;

    Lines.prototype.mouse_streng = .7;

    Lines.prototype.line_alpha = .6;

    Lines.prototype.geometry = new THREE.Geometry();

    Lines.prototype.particles = null;

    Lines.prototype.count = 0;

    function Lines(camera, scene) {
      var i, material, vectorf, _i, _ref;
      this.camera = camera;
      this.scene = scene;
      material = new THREE.ParticleBasicMaterial({
        color: 0xFFFFFF,
        size: 16,
        opacity: 0,
        map: THREE.ImageUtils.loadTexture("./img/particle.png"),
        transparent: true
      });
      for (i = _i = 0, _ref = this.amount; _i <= _ref; i = _i += 1) {
        vectorf = new THREE.Vector3((Math.random() * 2 - 1) * this.distance, (Math.random() * 2 - 1) * this.distance, (Math.random() * 2 - 1) * this.distance);
        this.geometry.vertices.push(vectorf);
      }
      TweenLite.to(material, 2.6, {
        opacity: 1,
        ease: Quad.EaseIn
      });
      this.particles = new THREE.ParticleSystem(this.geometry, material);
      this.scene.add(this.particles);
    }

    Lines.prototype.update = function() {
      var i, vertice, vertices, _i, _ref;
      vertices = this.geometry.vertices;
      for (i = _i = 0, _ref = vertices.length; _i < _ref; i = _i += 1) {
        vertice = vertices[i];
        vertice.y += Math.sin((this.count / 100) + (i / 10)) * .5;
      }
      this.geometry.verticesNeedUpdate = true;
      this.count += 1;
      return this.camera.lookAt(scene.position);
    };

    return Lines;

  })();

  /*
  MAIN
  */


  mouseX = 0;

  mouseY = 0;

  sw = window.innerWidth;

  sh = window.innerHeight;

  tanFOV = void 0;

  currentSection = void 0;

  currentSectionType = void 0;

  stats = void 0;

  camera = void 0;

  scene = void 0;

  renderer = void 0;

  composer = void 0;

  lines = void 0;

  $(document).ready(function() {
    preload();
    $(window).resize(function() {
      camera.setAspectRatio($(window).width() / $(window).height());
      return renderer.setSize($(window).width(), $(window).height());
    });
  });

  preload = function() {
    var objImage;
    objImage = new Image();
    objImage.onLoad = imagesLoaded();
    objImage.src = "img/particle.png";
  };

  imagesLoaded = function() {
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 5000);
    camera.position.z = 100;
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xFFFFFF, 0.0005);
    scene.add(camera);
    if (Detector.webgl) {
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        precision: "highp",
        maxLights: 4,
        stencil: true,
        preserveDrawingBuffer: true
      });
    } else if (Modernizr.canvas) {
      renderer = new THREE.CanvasRenderer();
    }
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    lines = new Lines(camera, scene, renderer);
    currentSection = new TestSection(camera, scene, renderer);
    currentSectionType = "test";
    addStat();
    addListener();
    mainLoop();
  };

  addStat = function() {
    stats = new Stats();
    stats.domElement.style.position = "absolute";
    stats.domElement.style.top = "0px";
    document.body.appendChild(stats.domElement);
  };

  addListener = function() {
    if (Modernizr.touch) {
      document.addEventListener("touchstart", onDocumentTouchStart, false);
      document.addEventListener("touchmove", onDocumentTouchMove, false);
    } else {
      document.addEventListener("mousemove", onDocumentMouseMove, false);
    }
  };

  onDocumentMouseMove = function(event) {
    mouseX = event.clientX - sw / 2;
    mouseY = event.clientY - sh / 2;
  };

  onDocumentTouchStart = function(event) {
    if (event.touches.length > 1) {
      event.preventDefault();
      mouseX = event.touches[0].pageX - sw / 2;
      mouseY = event.touches[0].pageY - sh / 2;
    }
  };

  onDocumentTouchMove = function(event) {
    if (event.touches.length === 1) {
      event.preventDefault();
      mouseX = event.touches[0].pageX - sw / 2;
      mouseY = event.touches[0].pageY - sh / 2;
    }
  };

  mainLoop = function() {
    requestAnimationFrame(mainLoop);
    stats.update();
    lines.update();
    if (currentSection) {
      currentSection.update();
    }
  };

  Monster = (function() {

    Monster.prototype.container = null;

    function Monster() {
      var container;
      container = new THREE.Object3D();
      return;
    }

    return Monster;

  })();

  Octopus = (function() {

    Octopus.prototype.tentacles = [];

    Octopus.prototype.sphere = null;

    Octopus.prototype.scene = null;

    function Octopus(scene) {
      var geometry, i, _i;
      this.scene = scene;
      for (i = _i = 0; _i < 20; i = _i += 1) {
        this.tentacle = new Tentacle();
        this.tentacle.mesh.rotation.x = Math.PI * 2 * Math.random();
        this.tentacle.mesh.rotation.y = Math.PI * 2 * Math.random();
        this.tentacle.mesh.rotation.z = Math.PI * 2 * Math.random();
        this.scene.add(this.tentacle.mesh);
        this.tentacles[i] = this.tentacle;
      }
      geometry = new THREE.SphereGeometry(50);
      this.sphere = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
        color: 0xFFFFFF
      }));
      this.scene.add(this.sphere);
      geometry = new THREE.SphereGeometry(60);
      this.sphere = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        opacity: .2,
        transparent: true
      }));
      this.scene.add(this.sphere);
      return;
    }

    Octopus.prototype.update = function() {
      var tentacle, _i, _len, _ref;
      _ref = this.tentacles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tentacle = _ref[_i];
        tentacle.update();
      }
      this.sphere.scale.x = this.sphere.scale.y = this.sphere.scale.z = 1 + .04 * Math.sin(tentacle.count);
    };

    return Octopus;

  })();

  Tentacle = (function() {

    Tentacle.prototype.PI180 = Math.PI / 180;

    Tentacle.prototype.materials = [];

    Tentacle.prototype.materialIndex = 1;

    Tentacle.prototype.nodes = [];

    Tentacle.prototype.numNodes = 30;

    Tentacle.prototype.mesh = null;

    Tentacle.prototype.headRadius = 18.0;

    Tentacle.prototype.girth = 6.4;

    Tentacle.prototype.reduction = 1.0;

    Tentacle.prototype.speed = 0.1;

    Tentacle.prototype.friction = 0.95;

    Tentacle.prototype.muscleRange = 30 * Math.PI / 180;

    Tentacle.prototype.frequency = 0.08;

    Tentacle.prototype.vector = 0;

    Tentacle.prototype.angle = 0;

    Tentacle.prototype.count = 0;

    Tentacle.prototype.forceAngle = 0 * Math.PI / 180;

    Tentacle.prototype.segmentsX = 11;

    function Tentacle() {
      this.createNodes();
      this.createMesh();
      return;
    }

    Tentacle.prototype.createMesh = function() {
      var geometry;
      this.materials.push(new THREE.MeshBasicMaterial({
        wireframe: true,
        color: 0xBBBBBB
      }));
      this.materials.push(new THREE.MeshNormalMaterial());
      this.materials.push(new THREE.MeshPhongMaterial({
        color: 0x333333
      }));
      this.materials.push(new THREE.MeshLambertMaterial({
        color: 0x333333
      }));
      geometry = new THREE.CylinderGeometry(this.headRadius, 0, this.numNodes * 10, this.segmentsX - 1, this.numNodes - 1, true);
      this.mesh = new THREE.Mesh(geometry, this.materials[2]);
    };

    Tentacle.prototype.createNodes = function() {
      var i, _i, _ref;
      for (i = _i = 0, _ref = this.numNodes; _i < _ref; i = _i += 1) {
        this.nodes.push({
          x: 0,
          y: 0,
          vx: 0,
          vy: 0
        });
      }
    };

    Tentacle.prototype.updateMesh = function() {
      var i, j, ondulationX, ondulationZ, radius, vertice, vertices, _i, _j, _ref, _ref1;
      vertices = this.mesh.geometry.vertices;
      for (i = _i = 0, _ref = this.numNodes; _i < _ref; i = _i += 1) {
        for (j = _j = 0, _ref1 = this.segmentsX; _j < _ref1; j = _j += 1) {
          vertice = vertices[i * this.segmentsX + j];
          vertice.y = i * this.girth;
          ondulationX = Math.cos(i / (this.numNodes - 1) * Math.PI * 2 + this.count) * 10;
          ondulationZ = Math.cos(i / (this.numNodes - 1) * Math.PI * 2 + this.count) * 10;
          radius = this.headRadius - this.headRadius * (i / this.numNodes) * this.reduction;
          vertice.x = Math.cos(j / 10 * Math.PI * 2 + this.count / 10) * radius + ondulationX;
          vertice.z = Math.sin(j / 10 * Math.PI * 2 + this.count / 10) * radius + ondulationZ;
        }
      }
      this.mesh.geometry.verticesNeedUpdate = true;
      this.mesh.geometry.computeBoundingSphere();
      this.mesh.geometry.normalsNeedUpdate = true;
      this.mesh.geometry.computeVertexNormals();
      this.mesh.material = this.materials[this.materialIndex];
    };

    Tentacle.prototype.updateMesh2 = function() {
      var i, j, node, ondulationX, ondulationZ, radius, vertice, vertices, _i, _j, _ref, _ref1;
      vertices = this.mesh.geometry.vertices;
      for (i = _i = 0, _ref = this.numNodes; _i < _ref; i = _i += 1) {
        node = this.nodes[i];
        for (j = _j = 0, _ref1 = this.segmentsX; _j < _ref1; j = _j += 1) {
          vertice = vertices[i * this.segmentsX + j];
          vertice.y = i * this.girth;
          ondulationX = node.x;
          ondulationZ = node.y;
          radius = this.headRadius - this.headRadius * (i / this.numNodes) * this.reduction;
          vertice.x = Math.cos(j / 10 * Math.PI * 2) * radius + node.x;
          vertice.z = Math.sin(j / 10 * Math.PI * 2) * radius + node.x;
        }
      }
      this.mesh.geometry.verticesNeedUpdate = true;
      this.mesh.geometry.computeBoundingSphere();
      this.mesh.geometry.normalsNeedUpdate = true;
      this.mesh.geometry.computeVertexNormals();
      this.mesh.geometry.computeFaceNormals();
      this.mesh.material = this.materials[this.materialIndex];
    };

    Tentacle.prototype.update = function() {
      this.count += this.frequency;
      this.updateMesh();
    };

    return Tentacle;

  })();

  TestSection = (function() {

    TestSection.prototype.previousX = 0;

    TestSection.prototype.previousY = 0;

    TestSection.prototype.cameraVector = 0;

    TestSection.prototype.vx = 0;

    TestSection.prototype.vy = 0;

    TestSection.prototype.friction = 0.97;

    TestSection.prototype.lightController = null;

    TestSection.prototype.cameraController = null;

    TestSection.prototype.gui = null;

    TestSection.prototype.snakes = [];

    function TestSection(camera, scene, render) {
      this.camera = camera;
      this.scene = scene;
      this.render = render;
      this.onRelease = __bind(this.onRelease, this);

      this.onMove = __bind(this.onMove, this);

      this.onTouch = __bind(this.onTouch, this);

      this.addEvents();
      this.gui = new GuiController(this);
      this.cameraController = new CameraController(camera);
      this.gui.controllCamera(this, this.cameraController);
      $("body").get(0).style.cursor = "url(./img/cursor_open.png),auto";
      this.camera.lookAt(scene.position);
      this.octopus = new Octopus(scene);
      return;
    }

    TestSection.prototype.addEvents = function() {
      window.addEventListener("mousedown", this.onTouch, false);
    };

    TestSection.prototype.onTouch = function(e) {
      e.preventDefault();
      this.previousX = e.pageX;
      this.previousY = e.pageY;
      window.addEventListener("mouseup", this.onRelease, false);
      window.addEventListener("mousemove", this.onMove, false);
      window.addEventListener("mouseleave", this.onRelease, false);
      $("body").get(0).style.cursor = "url(./img/cursor_close.png),auto";
    };

    TestSection.prototype.onMove = function(e) {
      var distX, distY;
      e.preventDefault();
      distX = e.pageX - this.previousX;
      distY = e.pageY - this.previousY;
      this.previousX = e.pageX;
      this.previousY = e.pageY;
      this.vx += distX / 1000;
      this.vy += distY / 20;
    };

    TestSection.prototype.onRelease = function(e) {
      e.preventDefault();
      window.removeEventListener("mouseup", this.onRelease, false);
      window.removeEventListener("mousemove", this.onMove, false);
      window.removeEventListener("mouseleave", this.onRelease, false);
      $("body").get(0).style.cursor = "url(./img/cursor_open.png),auto";
    };

    TestSection.prototype.update = function() {
      this.cameraController.update(this.vx, this.vy);
      this.octopus.update();
      this.vy *= this.friction;
      this.vx *= this.friction;
      renderer.render(scene, camera);
    };

    TestSection.prototype.close = function(callback) {
      this.state = "closing";
      $("#contact").fadeOut(400, callback);
    };

    return TestSection;

  })();

  GuiController = (function() {

    GuiController.prototype.gui = null;

    GuiController.prototype.camera = null;

    GuiController.prototype.light = null;

    function GuiController() {
      this.gui = new dat.GUI();
      return;
    }

    GuiController.prototype.controllScene = function(scene) {
      this.scene = this.gui.addFolder('Scene');
      this.scene.add(scene.fog, 'far', 0, 5000);
    };

    GuiController.prototype.controllCamera = function(section, cameraController) {
      this.camera = this.gui.addFolder('Camera');
      this.camera.add(cameraController, 'radius', 0, 1200);
      this.camera.add(section, 'friction', 0.95, 1);
    };

    GuiController.prototype.controllLight = function(lightController) {
      this.light = this.gui.addFolder('Light');
      this.light.add(lightController, 'lightAuto');
      this.light.addColor(lightController, 'ambientLightColor');
      this.light.addColor(lightController, 'cameraLightColor');
      this.light.add(lightController.cameraLight, 'distance', 0, 1000);
      this.light.add(lightController.cameraLight, 'intensity', 0, 2);
    };

    GuiController.prototype.controlMaterial = function(snake) {
      this.snake = this.gui.addFolder('Snake');
      this.snake.add(snake, 'materialIndex', 0, 3).step(1);
      this.snake.add(snake, 'girth', 1, 50).step(.1);
      this.snake.add(snake, 'headRadius', 1, 50).step(.1);
      this.snake.add(snake, 'reduction', 0, 5);
      this.snake.add(snake, 'frequency', 0, .4).step(.005);
      this.snake.open();
    };

    return GuiController;

  })();

}).call(this);
